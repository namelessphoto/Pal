#ifndef UE4SS_SDK_StemSpline_BP_HPP
#define UE4SS_SDK_StemSpline_BP_HPP

class AStemSpline_BP_C : public AActor
{
    class UBillboardComponent* Billboard;
    class UArrowComponent* Arrow3;
    class UArrowComponent* Arrow2;
    class UArrowComponent* Arrow;
    double IrregularityLevel;
    double IrregularityLevel_SubStems;
    double pointHeightAboveSurface;
    double pointHeightOnEdge;
    bool addCornerPoints;
    bool optimizeEdges;
    double traceSegmentLength;
    double downTraceLength;
    int32 Seed;
    int32 AmountOfSegments;
    int32 amountOfSegmentsDone;
    int32 edgeDetectionPrecision;
    double splineMeshAmountFactor;
    bool matchDirection&SurfaceNormal;
    TArray<FVector> Points;
    double subStemChance;
    bool showSplinePoints;
    FVector currentSubstemDirection;
    TArray<FVector> currentAddingSubstemPoints;
    int32 currentAddingSubstemAmountOfSegments;
    TArray<FSubStemStarter> subStemStarters;
    int32 currentAddingSubLevel;
    int32 maxSubStemLevels;
    TArray<class USplineComponent*> subStemSplines;
    double subStems_minGrowAlongLength;
    double subStems_maxGrowAlongLength;
    double subStemAngle;
    double subStemAngleAdditionalRandom;
    int32 maxSubstemAmount;
    int32 currentSubstemAmount;
    double perSubLevelLengthMultiplier;
    bool optimizeToLowerPoly;
    double optimizeMesh_DirectionMargin;
    double optimizeMesh_TangentMargin;
    bool StripStem;
    double StripStemStartWidth;
    double StripStemEndWidth;
    double StripStemFullWidthTime;
    class UStaticMesh* StripStemMain;
    class UStaticMesh* StripStemLowPoly;
    class UMaterialInterface* StripStemMaterial;
    double StartMeshScaleExtension;
    double EndMeshScaleExtension;
    FVector2D mainMeshScale;
    class UStaticMesh* splineMesh_Middle;
    class UStaticMesh* splineMesh_Start;
    class UStaticMesh* splineMesh_End;
    class UStaticMesh* splineMesh_LowPoly;
    class USplineComponent* MainSpline;
    TArray<int32> occupiedLengths;
    FVector startPointSeekDirection;
    double splineEndScale;
    double MainStemCurve;
    bool MainStemCurve_Bending;
    bool MainStemCurve_Incremental;
    double SubStemCurve;
    bool SubStemCurve_Bending;
    FVector lastTraceDirection;
    bool dropOffFromBottomEdges;
    int32 dropOffFromBottomEdges_maxDrop;
    int32 currentDropOffs;
    bool doingDropOffNow;
    double dropOffTolerance;
    double dropOff_EdgeAdjust;
    bool dropOffIfDownDirection;
    double dropOffIfDownDirection_reqLength;
    FVector dropOffPoint;
    double dropOffDownDirection_EdgeAdjust;
    bool makeBridges;
    bool makeBridgesWithSubStems;
    double BridgeChance;
    double BridgeGravity;
    double BridgeGravity_RandomAdd;
    class UCurveFloat* BridgeCurve;
    bool badTwistWorkaround;
    TArray<double> meshStartTimes;
    TArray<double> meshEndTimes;
    TArray<FVector> edgePoints_Locations;
    double splineMeshRoll;
    bool fixTangentUV-Stretching;
    TArray<double> edgePointsTimes;
    double SeekDistance;
    double SeekStartOffset;
    bool PrioritizeHigherObjects;
    bool showSeekTraces;
    int32 maxTraceChecks;
    bool useFixedSeekDirection;
    FVector FixedSeekDirection;
    bool makeBridgesFromCeilings;
    double strongTangentsReduction;
    bool 'X'_asUpVector;
    bool clampedEdges;
    bool CreateSplineMeshes;
    bool onlyFromEdges;
    double requiredEdgeSharpness;
    int32 maxBridgeAmount;
    int32 currentBridgeAmount;
    bool SplineMeshShadow;
    bool SplineMeshCollision;
    bool SubStemCurve_Incremental;
    bool hideDirectionArrows;
    TArray<FMeshToSpawnAlong> meshesToSpawnAlong;
    bool Click;
    TArray<FSkelMeshToSpawnAlong> SkelMeshesToSpawnAlong;
    bool useTargetPoint;
    class ASplineTarget_BP_C* TargetPoint;
    FVector Direction;
    FRandomStream RandomStream;
    bool ProcessSubStems;
    double IrregularityLevelSubStems_Neg;
    double IrregularityLevel_Neg;
    double BridgeGravityRandomAdd_Neg;
    FLinearColor FullRed;
    FLinearColor NoRed;

    void ConstructionLogic();
    void SetMainDirectionVector();
    void AddSkelMeshesAlongSpline(class USplineComponent* SplineComp);
    void [SubStem]-DoCheckSegment(FVector StartLocation, FVector relativeNormal, int32 currentSubLevel);
    void SeekForBridge(FVector StartLoc, FVector StartNormal, bool& bridgeBuilt, TArray<FVector>& bridgePoints, FVector& newSurfaceNormal);
    void (Bridge)_TraceTowardsDirection(FVector StartLocation, FVector relativeNormal, FVector Direction, bool& hitSomething, FVector& LastLocation, FVector& HitLocation, FVector& HitNormal, FVector& traceDirection);
    void FindBridgeEdge(int32 maxSegmentChecks, FVector fromWhere, FVector StartNormal, FVector Direction, bool& Found, FVector& edgeLocation, FVector& edgeNormal);
    void WorldLocToSplineTimeApprox(FVector worldLoc, int32 Iterations, double distanceTolerance_, class USplineComponent* SplineComponent, double StartTime, double EndTime, double& bestTime);
    void FindClosestVector(TArray<FVector>& inArray, FVector toVector, int32& closestValueIndex_);
    void CheckIfContainsVectorInDistance(TArray<FVector>& Array, double InDistance, FVector Vector, bool& Contains?);
    void FindClosestValue(TArray<double>& inArray, double toValue, int32& closestValueIndex_);
    void CheckIfContainsValueInRange(TArray<double>& Array, double Range: Min, double Range: Max, bool& Contains?);
    void AddMeshesAlongSpline(class USplineComponent* SplineComp);
    void AddSubStem(FVector StartLoc, FVector StartNormal, int32 currentSubLevel);
    void AddSplineMeshes(class USplineComponent* SplineComponent);
    void AddSplinePoints();
    void SearchForEdge(FVector searchStartLocation, FVector searchDirectionNormal, bool forSubstem, bool& FoundAnEdge_, FVector& foundEdgeLocation, FVector& foundEdgeNormal);
    void DoCheckSegment(FVector StartLocation, FVector relativeNormal);
    void TraceDown(FVector StartLocation, FVector relativeNormal, bool forBridgeSeek, FVector& HitLocation, FVector& HitNormal, bool& hitSomething);
    void TraceTowardsDirection(FVector StartLocation, FVector relativeNormal, bool forSubstem, FVector& HitLocation, FVector& HitNormal, FVector& LastLocation, FVector& traceDirection, bool& hitSomething, bool& targetReached);
    void FindStartPoint(FVector& StartLoc, FVector& StartNormal);
    void UserConstructionScript();
};

#endif
